#include spell_routines.inc
	
#define BELLOW_LOWEST_LVL		61

#define NOT_FOUND			0
#define INI_FILE			krust.ini
#define ZONEINFO_FILE	krust_zoneinfo.ini

#include gimp_metabolism.inc
#include gimp_modrod.inc
#include gimp_buffrequests.inc
#include gimp_buffstatus.inc
#include gimp_clickies.inc
#include gimp_debuffinfo.inc
#include gimp_consent.inc
#include gimp_dps.inc
#include gimp_xptrack.inc
#include gimp_assist.inc
#include gimp_lions.inc
#include gimp_spawncheck.inc
#include gimp_selflearn.inc
#include gimp_selfbuffs.inc
#include gimp_gote.inc

| Notes:
| * Requires /filter pcspells, to be *ALL* or *GRP* to see others debuffs
| * Requires hit modes->your hits to be normal or abbreviated for DPS counter to count melee damage
| * To automatically drop unwanted buffs, use MQ2BuffBlock plugin

|monk kicks
|Kick - level 1, cap 265
|Round Kick - level 5, cap 240
|Tiger Claw - level 10, cap 240
|Eagle Strike - level 20, cap 240
|Dragon Punch - level 25, cap 240
|Flying Kick - level 30, cap 240
#define MONK_KICK	"Eagle Strike"

#Event ToggleDisarm				"#*#[MQ2] toggledisarm#*#"
#Event ToggleTaunt				"#*#[MQ2] toggletaunt#*#"
#Event ToggleAutoRaidDump		"#*#[MQ2] toggleAutoRaidDump#*#"

|druid stuff:
#Event  UsedOakenGuard		"Your skin turns hard as oak."
#Event  UsedOakenGuard		"You have finished memorizing Oaken Guard."

|monk stuff:
#Event	UsedMend			"You mend your wounds and heal some damage."
Sub Event_UsedMend
	/echo [${Time}] Mend used
	/varset mendReuseTime 6m
	/varcalc mendReuseTime ${mendReuseTime}+4
/return

#Event BuffCheck		"[MQ2] buffcheck"
Sub Event_BuffCheck
	/declare i int local 0 
		/for i 0 to 25 
		/if (${Me.Buff[${i}].ID} && ${Me.Buff[${i}].Duration} < 100) { 
		/echo ** ${Int[${Math.Calc[${Me.Buff[${i}].Duration}/10+1]}]} minutes or less left on > ${Me.Buff[${i}].Name} <  
		} 
	/next i
	/echo *Done Checking Buff Durations
/return

Sub Event_UsedOakenGuard
	/varset oakenGuardReuseTime 15m
	/echo [${Time}] Oaken Guard used
/return

#Event	Camping				"#*#It will take you about 30 seconds to prepare your camp.#*#"
Sub Event_Camping
	/echo Camping - Ending macro!
	/endmacro
/return

Sub DoRegularUpdates
	/declare i int local 0
	/declare cnt int local 0
	/declare str string local
	/call CheckModRod
	/call CheckFood	
	/call CheckSpawns
	/call Event_JoinedGroup

	/if ((${Raid.Members} > 0) && ${Zone.Name.NotEqual["The Plane of Knowledge"]}) {
		|If i am anon or roleplay, turn off
		/if (${Me.Anonymous}) /anonymous off
		/if (${Me.Roleplaying}) /roleplay off
	}

	|Opens up friend window, since the macro uses a modified feedback xml file to display data
	/if (!${Window[FriendsWindow].Open}) /nomodkey /keypress alt+f
	/varset UpdateTimer 3s
/return

#Event AutoAcceptInvite "[MQ2] acceptinvite"
Sub Event_AutoAcceptInvite(string Line)
	/varcalc autoAcceptInvite ${autoAcceptInvite}+1
	/if (${autoAcceptInvite} == 1) {
		/echo # The next group or raid invite will be auto-accepted.
	} else {
		/echo # The next ${autoAcceptInvite} group or raid invites will be auto-accepted.
	}
/return

#Event HandleInvitedRaid "#1# invites you to join a raid."
Sub Event_HandleInvitedRaid(string Line, string Player)
	/if (!${autoAcceptInvite}) /return
	/varcalc autoAcceptInvite ${autoAcceptInvite}-1
	/echo # Auto-accepting raid invite from ${Player} <${Spawn[PC ${Player}].Guild}>
	/delay ${Math.Calc[${Math.Rand[3]}+1]}s
	/raidaccept
/return

#Event HandleInvitedGroup "#1# invites you to join a group."
Sub Event_HandleInvitedGroup(string Line, string Player)
	/if (!${autoAcceptInvite} || ${Group.Members}) /return
	/varcalc autoAcceptInvite ${autoAcceptInvite}-1
	/echo # Auto-accepting group invite from ${Player} <${Spawn[PC ${Player}].Guild}>
	/delay ${Math.Calc[${Math.Rand[3]}+1]}s
	/if (${Target.Type.Equal[PC]}) /squelch /target clear
	/invite
/return

#Event AutoAcceptRez "[MQ2] acceptrez"
Sub Event_AutoAcceptRez(string Line)
	/varset autoAcceptRez 1
	/echo # The next resurrection casted on you will be auto-accepted.
/return

|Event no longer triggers. Function is called from main loop when ${currentZone} changes
|#Event EnteredNewZone "You have entered #1#."
Sub Event_EnteredNewZone(string Line, string ZoneName)
	/echo Entered ${Zone.Name}
	/varset currentZone ${Zone.ID}
	/if (${gimp_spawncheck_loaded}) {
		/varset SpawnCheckTimer 0
		/call CheckSpawns
	}
	/if (${autoAcceptRez} && ${Spawn["${Me.Name}'s corpse"].ID}) {
		|fixme: did i zone to same zone where i am bound? fixme2: without below delay, auto looting of corpse messes up
		/echo # Zoned to ${Zone.Name} after auto accepting rez
		/delay 8s
		/call Event_LootMyCorpse
		/varset autoAcceptRez 0
		/if (${Me.Standing} && ${Me.MaxMana} && !${Me.Moving} && !${Me.Casting.ID}) /sit
	}
/return

Sub Main
	/declare autoAcceptRez int outer 0
	/declare autoAcceptInvite int outer 0

	|HUD variables
	/declare mcHUDmend				string outer
	/declare mcHUDoakenguard		string outer READY IN ???

	/declare mcHUDbuffmode		string outer
	/declare mcHUDbuffslots			int outer ${Math.Calc[15+(${Me.AltAbility["Mystical Attuning"]}/5)+${If[${Me.Level[>= 73]},1,0]}+${If[${Me.Level[>= 75]},1,0]}+${If[${Me.AltAbility["Embrace of the Keepers"].ID},1,0]}+${If[${Me.AltAbility["Embrace of the Dark Reign"].ID},1,0]}]}

	/declare mendReuseTime			timer outer 0
	/declare oakenGuardReuseTime	timer outer 0
		
	/declare UpdateTimer			timer outer 0
	/declare currentZone			int outer ${Zone.ID}
	
	|Load settings from INI file
	/declare AutoDisarm				int outer		${Ini[INI_FILE, ${Me.Name}, AutoDisarm, NOT_FOUND]}
	/declare AutoMend					int outer		${Ini[INI_FILE, ${Me.Name}, AutoMend, NOT_FOUND]}
	/declare AutoTaunt				int outer		${Ini[INI_FILE, ${Me.Name}, AutoTaunt, NOT_FOUND]}
	
	/declare i int local 0
		
	|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	|XXXX Adds aliases to the script
	|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	/squelch /alias /toggledisarm /echo toggledisarm
	/squelch /alias /toggletaunt /echo toggletaunt

	/squelch /alias /acceptrez /echo acceptrez
	/squelch /alias /acceptinvite /echo acceptinvite
	
	/squelch /alias /buffself /echo buffself
	/squelch /alias /castlions /echo castlions
	/squelch /alias /castgote /echo castgote
	/squelch /alias /buffcheck /echo buffcheck

	/declare tmp		int local 0

	/if (${AutoDisarm})	/echo Auto Disarm is ON
	/if (${AutoTaunt})	/echo Auto Taunt is ON
	/if (${AutoMend})		/echo Auto Mend is ON

	/call Init_DPS
	/call Init_XP
	/call Init_Assist
	/call Init_Clickies
	
	:krustloop
		/doevents

		/if (${Zone.ID}!=${currentZone}) /call Event_EnteredNewZone
		/if (!${UpdateTimer}) /call DoRegularUpdates
		/if (!${gimp_clickies_timer}) /call DoClickies			
				
		|Uses Healing Potion X if possible
		/if ((${Me.PctHPs} <= 25) && !${Me.Stunned} && !${Me.Invis} && !${Window[RespawnWnd].Open} && !${Me.Feigning}) {
			/if (${FindItem["Distillate of Divine Healing X"].InvSlot} && !${FindItem["Distillate of Divine Healing X"].Timer}) {
				|/potionbelt activate 1
				/call Cast "Distillate of Divine Healing X" item
				/echo # CLICKING HEALING POTION X!!!
				/popup CLICKING HEALING POTION X!!!
			} else {
				|Warrior invunerability
				/if (${Me.CombatAbilityReady["Furious Discipline"]}) {
					/doability "Furious Discipline"
					/echo # Using FURIOUS DISC!!!
					/delay 10
				}
			}
		}
	
		|Uses mod rod if possible
		/if (${Me.MaxMana} && !${Me.Invis} && (${Me.PctMana} <= 30) && (${Me.CurrentHPs} >= 1500)) {
			/if (${FindItem["Rod of Mystical Transvergance"].InvSlot} && !${FindItem["Rod of Mystical Transvergance"].Timer}) {
				/call Cast "Rod of Mystical Transvergance" item
				/echo # CLICKING MOD ROD!!!
			}
		}
		
		/if (${Me.MaxMana} && !${Me.Invis} && (${Me.PctMana} <= 30) && (${Me.CurrentHPs} >= 1500)) {
			/if (${FindItem["Wand of Elemental Transvergance "].InvSlot} && !${FindItem["Wand of Elemental Transvergance "].Timer}) {
				/call Cast "Wand of Elemental Transvergance " item
				/echo # CLICKING MOD ROD!!!
			}
		}

		|If rez box is open:
		/if (${autoAcceptRez} && ${Window[ConfirmationDialogBox].Open}) {
			/echo # Debug: Auto accepting rez in 5 sec
			/echo # Debug: Rez window text: ${Window[ConfirmationDialogBox].Child[CD_TextOutput].Text}
			/delay 5s
			/notify ConfirmationDialogBox Yes_Button leftmouseup
			/delay 5s
		}

		|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		|XX Melee classes
		|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		/if (${Me.Class.Name.Equal["Monk"]}) {
			|This will auto-kick the kick specified in MONK_KICK
			|Will only auto kick if auto attack is on, player has a target & it's a NPC, in LoS, <20 range, and player is not stunned
			/if (${Target.ID} && ${Target.Type.Equal[NPC]} && ${Me.Combat} && !${Me.Stunned} && ${Target.LineOfSight} && !${Me.Casting.ID}) {
				/if (${Me.AbilityReady["MONK_KICK"]} && (${Target.Distance} < 30)) {
					/doability "MONK_KICK"
					/if (${Spell["Celestial Tranquility"].Stacks}) {
						/if (${InvSlot[hands].Item.Name.Equal["Celestial Fists"]}) /call Cast "Celestial Fists" item
						/if (${InvSlot[hands].Item.Name.Equal["Gauntlets of Enlightenment"]}) /call Cast "Gauntlets of Enlightenment" item
					}
				}
				/if (${Me.AbilityReady["Mend"]}) {
					/if (${AutoMend} && ${Me.PctHPs} <= 70) {
						/echo Using Mend at ${Me.PctHPs}%
						/if (${Group.Members}) /delay 2s
						/if (${Me.PctHPs} <= 70) /doability "Mend"
					}
					/varset mcHUDmend READY
				} else {
					/varcalc tmp ${mendReuseTime}/10
					/varset mcHUDmend READY IN ${tmp}s
				}
				
				/if (${AutoDisarm} && ${Me.AbilityReady["Disarm"]} && (${Target.Distance} < 15)) /doability "Disarm"
			}
		}

		/if (${Me.Class.Name.Equal["Bard"]} || ${Me.Class.Name.Equal["Ranger"]} || ${Me.Class.Name.Equal["Rogue"]} || ${Me.Class.Name.Equal["Warrior"]}) {

			/if (${Target.ID} && ${Target.Type.Equal[NPC]} && ${Me.Combat} && !${Me.Stunned} && ${Target.LineOfSight} && !${Me.Casting.ID}) {
				|Warrior kick, need to put Kick on ability hotkey for it to work
				/if (${AutoTaunt}) {
					|Bazu bellow on mobs at lv55 or above (dont waste bellow on fearable in mpg fear trial), dont bellow if im ungrouped
					/if ((${Me.TargetOfTarget.ID} && (${Me.TargetOfTarget.ID} != ${Me.ID})) && ${Group.Members} ) {
						/if ((${Me.PctEndurance} >= 20) && !${Me.Stunned} && ${Me.CombatAbilityReady["Bazu Bellow"]} && (${Target.Distance} < 50) && (${Target.Level} >= BELLOW_LOWEST_LVL)) {
							/echo # BELLOW: ${Target.CleanName} (${Me.TargetOfTarget.Name} has aggro)
							/doability "Bazu Bellow"
							/delay 10
						}
					}

					|just taunt
					/if (${Me.AbilityReady["Taunt"]} && (${Target.Distance} < 20) && ${Me.TargetOfTarget.Name.NotEqual[${Me.Name}]}) {
						/echo # TAUNT: ${Target.CleanName} (${Me.TargetOfTarget.Name} has aggro)
						/doability "Taunt"
						/delay 10
					}
							
					/if (${InvSlot[offhand].Item.Type.Equal[shield]}) {
						/if (${Me.AbilityReady["Bash"]} && (${Target.Distance} < 20)) {
							/echo # BASH: ${Target.CleanName}
							/doability "Bash"
						}
					} else {
						/if (${Me.AbilityReady["Kick"]} && (${Target.Distance} < 20)) /doability "Kick"
					}
				}
				/if (${Me.AbilityReady["Kick"]} && (${Target.Distance} < 20)) /doability "Kick"
				/if (${AutoDisarm} && ${Me.AbilityReady["Disarm"]} && (${Target.Distance} < 15)) /doability "Disarm"
			}
		}


		|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		|XX Priest classes
		|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		/if (${Me.Class.Name.Equal["Druid"]} || ${Me.Class.Name.Equal["Cleric"]} || ${Me.Class.Name.Equal["Shaman"]}) {
			|Stand up when FM and spell book is not open
			/if ((${Me.PctMana} >= 99) && ${Me.Sitting} && !${Me.Feigning} && !${Me.Invis} && !${Me.AFK} && !${Window[SpellBookWnd].Open}) {
				/echo Sitting & FM, standing
				|Wait 5 sec & process events in between, so /camp can be triggered
				:StandLoop
				/for i 1 to 5
				/delay 1s
				/doevents
				/next i
				/if (${Me.Sitting}) /stand
			}
		}
	/goto :krustloop
/return 

Sub Event_ToggleDisarm
	/if (${AutoDisarm}) {
		/varset AutoDisarm 0
		/echo Disarm mode is now OFF
	} else {
		/varset AutoDisarm 1
		/echo Disarm mode is now ON
	}
	/ini "INI_FILE" "${Me.Name}" "AutoDisarm" "${AutoDisarm}"
/return

Sub Event_ToggleTaunt
	/if (${AutoTaunt}) {
		/varset AutoTaunt 0
		/echo Taunt mode is now OFF
	} else {
		/varset AutoTaunt 1
		/echo Taunt mode is now ON
	}
	/ini "INI_FILE" "${Me.Name}" "AutoTaunt" "${AutoTaunt}"
/return